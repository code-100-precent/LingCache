# Redis 数据结构面试题总结

本文档总结了 Redis 五种核心数据结构的常见面试题和答案。

## 一、String (SDS)

### Q1: 为什么 Redis 不直接使用 C 语言的字符串？

**答案：**
C 字符串有以下问题：
1. **O(n) 获取长度**：需要遍历到 `\0` 才能知道长度，性能差
2. **不能存储二进制数据**：`\0` 会被误判为字符串结束符
3. **频繁的内存重分配**：每次 append 都可能需要 realloc，性能差
4. **缓冲区溢出风险**：没有长度信息，容易越界

SDS 通过存储长度信息解决了这些问题。

### Q2: SDS 的预分配策略是什么？

**答案：**
空间预分配策略（减少内存重分配）：
- **len < 1MB**：分配 `len * 2` 的空间（预留 100%）
- **len >= 1MB**：每次多分配 1MB

这样可以减少内存重分配次数，提高性能。

### Q3: SDS 如何实现二进制安全？

**答案：**
使用 `len` 字段记录实际长度，而不是依赖 `\0` 结束符。
- C 字符串：`"hello\0world"` 只能读取到 `"hello"`
- SDS：可以完整存储 `"hello\0world"`，通过 `len` 知道完整长度

### Q4: SDS 的惰性空间释放是什么？

**答案：**
当字符串缩短时，不立即释放多余的内存，而是保留在 `alloc` 中。
- 优点：如果后续需要扩展，可以复用这些空间，避免频繁的内存分配
- 缺点：可能浪费一些内存（可以通过 `sdsRemoveFreeSpace` 主动释放）

### Q5: SDS 为什么有多种 header 类型？

**答案：**
为了优化内存使用：
- **sdshdr8**：len/alloc 各 1 字节，适合 <= 255 字节的字符串
- **sdshdr16**：len/alloc 各 2 字节，适合 <= 65535 字节的字符串
- **sdshdr32**：len/alloc 各 4 字节，适合 <= 4GB 的字符串
- **sdshdr64**：len/alloc 各 8 字节，适合超大字符串

小字符串使用小的 header，避免浪费内存。

---

## 二、List (Quicklist + Listpack)

### Q1: Redis List 为什么使用 quicklist 而不是简单的双向链表？

**答案：**
简单双向链表的问题：
1. **内存开销大**：每个节点都有 prev/next 指针（64位系统每个指针8字节）
2. **内存碎片严重**：每个节点单独分配，内存不连续
3. **缓存局部性差**：节点分散在内存中，CPU 缓存命中率低

Quicklist 的优势：
1. **减少指针开销**：每个节点包含多个元素（listpack），减少指针数量
2. **支持压缩**：可以对节点进行 LZF 压缩，节省内存
3. **更好的缓存局部性**：节点内元素连续存储
4. **平衡性能**：避免大块内存分配，同时保持较好的查找性能

### Q2: Listpack 和 Ziplist 有什么区别？

**答案：**
Listpack 是 Ziplist 的改进版：

**Ziplist 的问题（连锁更新）：**
- 使用 `prevlen` 字段记录前一个元素的长度
- 当插入/删除元素时，可能导致后续元素的 `prevlen` 需要更新
- 最坏情况下需要更新所有后续元素（O(n²)）

**Listpack 的改进：**
- 使用总长度字段，避免了连锁更新问题
- 更简单的实现，性能更好
- Redis 7.0 开始，List 使用 listpack 替代 ziplist

### Q3: Quicklist 的压缩策略是什么？

**答案：**
Quicklist 支持对节点进行 LZF 压缩：
- **compress 参数**：控制压缩深度（两端不压缩的节点数）
- 例如 `compress=1`：两端各保留 1 个节点不压缩
- **压缩的好处**：节省内存
- **压缩的代价**：增加 CPU 开销（压缩/解压）

### Q4: 为什么 List 要支持编码转换？

**答案：**
为了在不同场景下优化性能：
- **小列表**：listpack 更节省内存，操作更快
- **大列表**：quicklist 避免大块内存分配，支持压缩

根据数据规模动态选择最优编码。

### Q5: Quicklist 的 fill 参数是什么？

**答案：**
`fill` 参数控制每个节点最多包含的元素数：
- **fill > 0**：每个节点最多包含 `fill` 个元素
- **fill < 0**：每个节点最多包含 `|fill| * 8KB` 的数据

这样可以控制节点大小，平衡内存和性能。

---

## 三、Set (Intset + Hashtable)

### Q1: 为什么 Set 要使用两种编码方式？

**答案：**
为了在不同场景下优化性能：
- **小整数集合**：intset 更节省内存，查找也很快（O(log n)）
- **大集合或包含字符串**：hashtable O(1) 查找，更高效

根据数据特征动态选择最优编码。

### Q2: Intset 的变长编码是什么？

**答案：**
Intset 根据集合中最大整数选择编码：
- 如果所有整数 < 2^15，使用 **int16**（每个元素2字节）
- 如果所有整数 < 2^31，使用 **int32**（每个元素4字节）
- 否则使用 **int64**（每个元素8字节）

这样可以节省内存，例如只有小整数时不需要8字节。

### Q3: Intset 为什么是有序的？

**答案：**
有序的好处：
1. **支持二分查找**：O(log n) 查找
2. **去重简单**：插入时检查相邻元素即可
3. **支持范围操作**：如 SINTER（求交集）等操作更高效

插入时需要维护有序性，但查找很快。

### Q4: Set 的编码转换是单向的吗？

**答案：**
是的，只能从 intset → hashtable，不能反向：
- intset 只能存储整数
- 一旦转换为 hashtable，可能包含非整数元素
- 即使后来删除了所有非整数，也不会转换回去（避免频繁转换）

### Q5: Intset 升级（upgrade）是什么？

**答案：**
当添加一个超出当前编码范围的整数时，需要升级：
- 例如：当前是 int16，添加一个 > 32767 的整数
- 需要将所有元素从 int16 升级到 int32
- 这是一个 **O(n)** 操作，但很少发生

---

## 四、Sorted Set (ZSet) - Skiplist + Dict

### Q1: 为什么 ZSet 要同时使用 Skiplist 和 Dict？

**答案：**
两种数据结构互补：
- **Skiplist**：支持范围查询（ZRANGE）、按 score 排序
- **Dict**：支持 O(1) 获取 member 的 score（ZSCORE）

如果只用 Skiplist，ZSCORE 需要 O(log n) 查找。
如果只用 Dict，无法高效支持范围查询。

### Q2: Skiplist 的层数是如何确定的？

**答案：**
使用随机算法：
- 每个节点有 **50% 概率**进入上一层
- 层数从 1 开始，每次有 50% 概率 +1
- 最大层数通常限制为 32（Redis 默认）
- **期望层数**：E[L] = 1/(1-p) ≈ 2（p=0.5）

### Q3: Skiplist 和平衡树（如红黑树）有什么区别？

**答案：**

**Skiplist 的优势：**
1. **实现简单**：代码量少，易于理解和维护
2. **范围查询更高效**：链表结构，遍历方便
3. **并发友好**：可以用无锁数据结构实现

**平衡树的优势：**
1. **最坏情况性能有保证**：Skiplist 是概率性的，最坏情况可能退化为链表
2. **内存开销更小**：不需要多个指针层

### Q4: ZSet 的 score 可以重复吗？member 呢？

**答案：**
- **score 可以重复**：多个 member 可以有相同 score
- **member 不能重复**：相同 member 会更新 score

当 score 相同时，按 member 的字典序排序。

### Q5: ZSet 的范围查询是如何实现的？

**答案：**
使用 Skiplist 的链表特性：
- **ZRANGE**：从指定位置开始，沿着底层链表遍历
- **ZRANGEBYSCORE**：先定位到 score 范围的起点，然后遍历

时间复杂度：**O(log n + m)**，n 是总数，m 是返回的元素数。

---

## 五、Hash (Listpack + Dict)

### Q1: 为什么 Hash 要使用两种编码方式？

**答案：**
为了在不同场景下优化性能：
- **小哈希表**：listpack 更节省内存，查找也很快（O(n) 但 n 很小）
- **大哈希表**：dict O(1) 查找，更高效

根据数据规模动态选择最优编码。

### Q2: Listpack 中 Hash 的 field-value 是如何存储的？

**答案：**
按顺序存储，field 和 value 交替出现：
```
[field1][value1][field2][value2]...
```

查找时需要遍历，但小数据时性能可以接受。

### Q3: Hash 的编码转换是单向的吗？

**答案：**
是的，只能从 listpack → dict，不能反向：
- 一旦转换为 dict，可能包含大字段或大量元素
- 即使后来删除了大字段，也不会转换回去（避免频繁转换）

### Q4: Hash 和 String 有什么区别？

**答案：**
Hash 适合存储对象（多个字段）：

**Hash 方式：**
```
HSET user:1 name "Alice" age "30"
HGETALL user:1
```

**String 方式：**
```
SET user:1:name "Alice"
SET user:1:age "30"
```

**Hash 的优势：**
1. **原子操作**：可以同时操作多个字段
2. **内存效率**：小对象时更节省内存
3. **操作方便**：HGETALL 一次获取所有字段

### Q5: Hash 的渐进式 rehash 是什么？

**答案：**
当 dict 需要扩容时，Redis 使用渐进式 rehash：
- **不是一次性迁移**所有数据，而是分多次
- **每次操作时迁移一部分**数据
- 这样避免阻塞，保证响应时间

这是 dict 的特性，Hash 作为使用者自动获得。

---

## 六、通用问题

### Q1: Redis 为什么使用多种编码方式？

**答案：**
为了在不同场景下优化性能：
- **小数据**：使用紧凑格式（listpack、intset），节省内存
- **大数据**：使用高效结构（dict、skiplist），保证性能

根据数据规模动态选择最优编码。

### Q2: 编码转换的触发条件是什么？

**答案：**
通常有两个条件：
1. **元素数量**：超过某个阈值（如 512、128）
2. **元素大小**：超过某个阈值（如 64 字节）

满足任一条件就会转换。

### Q3: 编码转换是单向的还是双向的？

**答案：**
大多数是**单向的**（只能从小编码到大编码）：
- 一旦转换为大编码，可能包含大元素
- 即使后来删除了大元素，也不会转换回去
- 避免频繁转换的开销

### Q4: Redis 数据结构的内存优化策略有哪些？

**答案：**
1. **变长编码**：根据数据大小选择编码（如 intset、SDS header）
2. **紧凑格式**：小数据使用 listpack、ziplist 等
3. **压缩**：quicklist 节点可以压缩
4. **共享对象**：小整数、空字符串等共享
5. **惰性释放**：SDS 缩短时不立即释放内存

### Q5: Redis 数据结构的性能特点是什么？

**答案：**

| 数据结构 | 查找 | 插入 | 删除 | 范围查询 |
|---------|------|------|------|----------|
| String (SDS) | O(1) | O(1) | O(1) | - |
| List (Quicklist) | O(n) | O(1) | O(1) | O(n) |
| Set (Intset) | O(log n) | O(n) | O(n) | - |
| Set (Hashtable) | O(1) | O(1) | O(1) | - |
| ZSet (Skiplist) | O(log n) | O(log n) | O(log n) | O(log n + m) |
| Hash (Listpack) | O(n) | O(n) | O(n) | - |
| Hash (Dict) | O(1) | O(1) | O(1) | - |

---

## 七、实战问题

### Q1: 如何选择合适的数据结构？

**答案：**
- **String**：简单键值对、计数器、缓存
- **List**：队列、栈、时间线
- **Set**：去重、集合运算、标签
- **ZSet**：排行榜、延时队列、范围查询
- **Hash**：对象存储、字段更新

### Q2: 如何优化 Redis 内存使用？

**答案：**
1. **使用合适的数据结构**：小数据用紧凑格式
2. **设置合理的过期时间**：避免数据堆积
3. **使用压缩**：quicklist 压缩节点
4. **避免大 key**：拆分大对象
5. **使用共享对象**：小整数等

### Q3: Redis 数据结构的线程安全吗？

**答案：**
Redis 是**单线程**的（命令执行），所以：
- **数据结构操作是原子的**：不需要加锁
- **不会有竞态条件**：命令串行执行
- **但要注意**：Lua 脚本、事务等特殊情况

### Q4: Redis 数据结构的持久化？

**答案：**
Redis 支持两种持久化方式：
1. **RDB**：快照，定期保存
2. **AOF**：追加日志，实时保存

数据结构会按照编码格式序列化保存。

### Q5: Redis 数据结构的分布式？

**答案：**
Redis Cluster 使用**哈希槽**（16384 个槽）：
- 每个 key 通过 CRC16 计算槽位
- 槽位分布在不同的节点上
- 数据结构不影响分布式逻辑

---

## 总结

Redis 的五种核心数据结构都有其设计精妙之处：
1. **String (SDS)**：二进制安全、O(1) 长度、预分配
2. **List (Quicklist)**：双向链表 + listpack，支持压缩
3. **Set (Intset/Hashtable)**：根据数据特征选择编码
4. **ZSet (Skiplist + Dict)**：范围查询 + O(1) 查找
5. **Hash (Listpack/Dict)**：小对象紧凑，大对象高效

理解这些数据结构的原理和设计思想，有助于：
- 更好地使用 Redis
- 优化应用性能
- 通过技术面试

